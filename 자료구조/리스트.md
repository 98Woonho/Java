# 리스트
- `리스트(List)` : 요소들의 순서를 유지하며 저장할 수 있는 자료구조. 순차적으로 데이터를 저장하고, 저장된 데이터에 인덱스를 사용해 접근 가능.

## ArrayList
- `ArrayList` : 동적 배열을 기반으로 한 리스트 구현체. 배열과 유사하지만, 크기가 고정되어 있지 않으며 필요에 따라 크기를 동적으로 조절 할 수 있음.
- ### 특징
  - **인덱스 접근** : 배열과 마찬가지로 인덱스를 통해 빠르게 요소에 접근할 수 있음. `O(1)`의 시간 복잡도를 가짐.
  - **삽입/삭제 성능** : 배열의 중간에 요소를 삽입하거나 삭제할 때는 해당 인덱스 이후의 요소들을 이동시켜야 하므로, 성능이 떨어짐. 이 경우 시간 복잡도는 최악의 경우 `O(n)`.

- ### 예시
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();

        // 요소 추가
        list.add("apple");
        list.add("banana");
        list.add("cherry");

        // 인덱스를 통한 접근
        System.out.println(list.get(1));  // 출력: banana

        // 요소 삭제
        list.remove(0);  // "apple" 삭제

        // 요소 확인
        System.out.println(list);  // 출력: [banana, cherry]
    }
}
```

## LinkedList
- `LinkedList` : 노드들이 포인터로 연결된 형태의 리스트. 각 노드는 데이터와 다음 노드를 가리키는 참조를 포함.
- ### 특징
  - **인덱스 접근** : 특정 인덱스에 있는 요소에 접근하려면 처음부터 순차적으로 탐색해야 하므로, `ArrayList`보다 느림. 시간 복잡도는 `O(n)`
  - **삽입/삭제 성능** : 리스트의 앞, 중간, 또는 끝에 요소를 삽입하거나 삭제할 때, 요소 이동이 필요 없기 때문에 빠른 성능을 가짐. 시간 복잡도는 `O(1)` 또는 `O(n)`

- ### 예시
```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();

        // 요소 추가
        list.add("apple");
        list.add("banana");
        list.add("cherry");

        // 리스트의 앞에 요소 추가
        list.addFirst("avocado");

        // 리스트의 끝에 요소 추가
        list.addLast("date");

        // 요소 삭제
        list.remove(1);  // "apple" 삭제

        // 요소 확인
        System.out.println(list);  // 출력: [avocado, banana, cherry, date]
    }
}
```

## 주요 메서드
- `add(E element)` : 리스트의 끝에 요소를 추가
- `add(int index, E element)` : 지정된 위치에 요소를 삽입. 기존 요소들은 오른쪽으로 이동
- `remove(int index)` : 지정된 위치의 요소를 제거하고, 그 요소를 반환
- `remove(Object o)` : 