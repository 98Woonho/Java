# 추상 클래스와 인터페이스

## 목차

## 1. 추상 클래스와 추상 메서드

### 1-1. 추상 메서드
다형성을 위해 메서드의 선언은 통일해야 하지만, 실제로 구현하는 내용은 자식 클래스마다 달라야 할 때, 부모 클래스의 메서드는 비워두고 자식 클래스에서 오버라이딩하여 구현해낼 수 있었다. 자바는 이와 같은 경우를 공식 지원하며 방법을 제공하고 있다. 선언부만 작성하고 구현부는 작성하지 않고 남겨둔 미완성 메서드를 `추상 메서드`라고 부른다.
<br/>
추상 메서드의 특징은 다음과 같다.
```html
- 추상 메서드를 선언할 때는 abstract 키워드를 함께 표기해야 한다.
- 메서드 구현부인 중괄호({}) 대신 구현부가 없다는 의미로 선언부 끝에 세미콜론(;)을 사용한다.
- 반드시 추상 클래스에서만 구현 되어야 한다.
```

추상 메서드를 선언하는 방법은 다음과 같다.
```java
[접근 제한자] abstract [반환 타입] [메서드 이름] ([매개변수1], [매개변수2], ...);
```

### 1-2. 추상 클래스
자바에서는 하나 이상의 추상 메서드를 포함하는 클래스를 가리켜 추상 클래스라고 한다.
<br/>
추상 클래스를 선언하는 방법은 추상 메서드와 유사하다.
```java
[접근 제한자] abstract class [클래스 이름] {
    // 필드
    // 생성자
    // 메서드 (추상 메서드 포함)
}
```

추상 클래스로 선언되는 클래스는 다음과 같은 제약 조건을 가진다.
```
- 일반 클래스처럼 독립적으로 생성자를 호출해 객체를 생성할 수 없다.
- 자식 클래스의 생성자에서 super()를 통해 추상 클래스의 생성자를 호출하여 부모 객체를 생성한 후 자식 객체를 생성한다.
```

<br/>

추상 클래스가 반드시 추상 메서드를 가져야 하는 것은 아니다. 만약 자식 클래스들이 반드시 구현해야 하는 메서드가 있다면, 추상 메서드로 해당 메서드를 부모 클래스에 선언해 둘 수 있다.
<br/>

추상 메서드가 선언된 추상 클래스는 다음과 같은 힘을 가진다.
```
추상 클래스를 상속받은 모든 자식 클래스는 반드시 추상 메서드를 오버라이딩 및 재정의하여 구현해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.
```

### 1-3. 추상 클래스와 추상 메서드의 용도
추상 클래스와 추상 메서드의 용도는 다음과 같다.
```
- 자식 클래스 간의 공통적인 필드와 메서드 이름을 통일할 수 있다.
- 반드시 구현해야 하는 메서드를 선언함으로써 공통 규격을 제공한다.
```


## 2. 인터페이스 구현
모든 메서드가 추상 메서드인 일종의 추상 클래스를 우리는 `인터페이스`라고 부른다. 인터페이스는 추상 메서드와 상수로 이루어져 있으며, 추상 클래스와 마찬가지로 스스로 객체를 생성할 수 없다. 언뜻 보면 인터페이스와 추상 클래스가 같은 역할을 하는 것처럼 느껴질 수 있지만, 완전히 다르다.
<br/>

추상 클래스는 자식 클래스들의 공통적 특징을 추출하고 제공하는 것이 주된 역할이었다면, 인터페이스는 그뿐 아니라 다른 클래스 코드들과의 중간 매개 역할을 하는 것을 중점으로 생각할 수 있다.

### 2-1. 인터페이스 선언
인터페이스는 어떤 형태로도 객체를 만들 수 없기 때문에 클래스가 아니다. 인터페이스는 객체의 매개체, 즉 객체를 사용하는 방법을 제공하는 새로운 블록이라고 할 수 있다.
<br/>

인터페이스를 선언할 때는 `interface` 키워드를 함께 사용하며, 다음과 같이 선언한다.
```java
[접근 제한자] interface [인터페이스 이름] {
    ... // 코드
}
```

클래스와 달리 인터페이스의 모든 필드는 public / static / final이어야 하며, 모든 메서드는 public / abstract이어야 한다. 이는 모든 인터페이스에 공통으로 적용되는 사항이므로 생략이 가능하다.

```java
public interface Phone {
    int MAX_BATTERY_CAPACITY = 100; // (public static final) int 와 동일
    
    void powerOn(); // (abstract) void powerOn(); 와 동일
    void powerOff(); // (abstract) void powerOff(); 와 동일
}
```

### 2-2. 인터페이스 사용
인터페이스를 구현하는 클래스를 선언할 때는 `implements` 키워드를 사용한다. 그리고 하나의 클래스로 여러 개의 인터페이스를 구현할 수 있다.
<br/>

인터페이스를 구현하는 클래스는 아래와 같이 선언한다.
```java
[접근 제한자] class [클래스 이름] implements [인터페이스 이름1], [인터페이스 이름2], ... {
    ...  // 코드   
}
```

인터페이스를 사용함으로써 아래와 같은 장점을 발견할 수 있다.
```
- 실제 구현 클래스의 내용을 전혀 보지 않고도 개발 코드로 객체를 사용할 수 있다. (정보 은닉)
- 구현 클래스들이 독립적으로 구현되고 사용될 수 있다. 개발 코드에서 객체 변경이 필요할 때, 개발 코드의 수정을 최소화 할 수 있다. (모듈화)
```

## 3. 인터페이스 상속
인터페이스 역시 인터페이스끼리 상속 관계를 만들 수 있다. 클래스의 상속과 마찬가지로 `extends` 키워드를 사용하며, 다중 상속이 가능하기 때문에 콤마(`,`)를 이용해서 다움과 같이 선언한다.

```java
[접근 제한자] interface [인터페이스 이름] extends [인터페이스1], [인터페이스2], ... {
    ...;
}
```

클래스의 상속과 마찬가지로 인터페이스 상속을 선언하면, 하위 클래스는 상위 클래스의 모든 멤버를 상속받게 된다. 따라서 만약 하위 인터페이스를 구현하는 클래스가 있다면, 해당 클래스는 하위 인터페이스의 추상 메서드를 포함하여 상위 인터페이스의 추상 메서드까지 구현해야 한다.

> ### 인터페이스 상속
> ```java
> interface Microphone {
>     void sing();
> }
> 
> interface Speaker {
>     void music();
> }
> 
> interface BluetoothMIC extends Microphone, Speaker {
>     void connect();
> }
> 
> class TJmic implements BluetoothMIC {
>     @Override
>     public void sing() {
>         System.out.println("마이크에 대고 노래를 부릅니다.");
>     }
> 
>     @Override
>     public void music() {
>         System.out.println("마이크에 장착된 스피커로 반주가 나옵니다.");
>     }
> 
>     @Override
>     public void connect() {
>         System.out.println("핸드폰과 블루투스가 연결 되었습니다.");
>     }
> }
> 
> 
> public class practice {
>     public static void main(String[] args) {
>         System.out.println("---TJmic 객체---");
>         TJmic tj = new TJmic();
>         tj.connect();
>         tj.music();
>         tj.sing();
> 
>         System.out.println("\n---TJmic 객체를 BluetoothMIC로 타입 변환---");
>         BluetoothMIC bm = tj;
>         bm.connect();
>         bm.music();
>         bm.sing();
> 
>         System.out.println("\n---TJmic 객체를 Microphone으로 타입 변환---");
>         Microphone m = tj;
>         // m.connect(); // 호출 불가능
>         // m.music();   // 호출 불가능
>         m.sing();
> 
>         System.out.println("\n---TJmic 객체를 Specker로 타입 변환---");
>         Speaker s = tj;
>         // s.connect(); // 호출 불가능
>         s.music();
>         // s.sing();    // 호출 불가능
>     }
> }
> ```
> ### 실행 결과
> ```
> ---TJmic 객체---
> 핸드폰과 블루투스가 연결 되었습니다.
> 마이크에 장착된 스피커로 반주가 나옵니다.
> 마이크에 대고 노래를 부릅니다.
> 
> ---TJmic 객체를 BluetoothMIC로 타입 변환---
> 핸드폰과 블루투스가 연결 되었습니다.
> 마이크에 장착된 스피커로 반주가 나옵니다.
> 마이크에 대고 노래를 부릅니다.
> 
> ---TJmic 객체를 Microphone으로 타입 변환---
> 마이크에 대고 노래를 부릅니다.
> 
> ---TJmic 객체를 Specker로 타입 변환---
> 마이크에 장착된 스피커로 반주가 나옵니다.
> ```
